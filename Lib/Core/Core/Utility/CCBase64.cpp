//
//  CCBase64.cpp
//  Core
//
//  Created by lichangchun on 3/27/14.
//  Copyright (c) 2014 lichangchun. All rights reserved.
//

#include "CCBase64.h"
#include "config.h"
#include <string.h>
/*
 base64的编码都是按字符串长度，以每3个8bit的字符为一组，针对每组，首先获取每个字符的ASCII编码，
 然后将ASCII编码转换成8bit的二进制，得到一组3*8=24bit的字节,
 再将这24bit划分为4个6bit的字节，并在每个6bit的字节前面都填两个高位0，得到4个8bit的字节,
 然后将这4个8bit的字节转换成10进制，对照Base64编码表 （base64_enc_map），得到对应编码后的字符。

（注：1. 要求被编码字符是8bit的，所以须在ASCII编码范围内，\u0000-\u00ff，中文就不行。
　　　2. 如果被编码字符长度不是3的倍数的时候，则都用0代替，对应的输出字符为=）
 */
static const unsigned char base64_enc_map[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
//static const unsigned char base64_enc_map[64] =
//{
//    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',
//    'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',
//    'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd',
//    'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
//    'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x',
//    'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7',
//    '8', '9', '+', '/'
//};
static const unsigned char kWebSafe_base64_enc_map[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
static const char kBase64PaddingChar = '=';
static const char kBase64InvalidChar = 127;
#define BAD kBase64InvalidChar

static const unsigned char base64_dec_map[128] =
{
// This array was generated by the following code:
// #include <sys/time.h>
// #include <stdlib.h>
// #include <string.h>
// main()
// {
//   static const char Base64[] =
//     "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
//   char *pos;
//   int idx, i, j;
//   printf("    ");
//   for (i = 0; i < 255; i += 8) {
//     for (j = i; j < i + 8; j++) {
//       pos = strchr(Base64, j);
//       if ((pos == NULL) || (j == 0))
//         idx = BAD;
//       else
//         idx = pos - Base64;
//       if (idx == 99)
//         printf(" %2d,     ", idx);
//       else
//         printf(" %2d/*%c*/,", idx, j);
//     }
//     printf("\n    ");
//   }
// }
    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,
    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,
    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,
    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,
    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,
    BAD,    BAD,    BAD,    62,     BAD,    BAD,    BAD,    63,
    52,     53,     54,     55,     56,     57,     58,     59,
    60,     61,     BAD,    BAD,    BAD,    64,     BAD,    BAD,
    BAD,    0,      1,      2,      3,      4,      5,      6,
    7,      8,      9,      10,     11,     12,     13,     14,
    15,     16,     17,     18,     19,     20,     21,     22,
    23,     24,     25,     BAD,    BAD,    BAD,    BAD,    BAD,
    BAD,    26,     27,     28,     29,     30,     31,     32,
    33,     34,     35,     36,     37,     38,     39,     40,
    41,     42,     43,     44,     45,     46,     47,     48,
    49,     50,     51,     BAD,    BAD,    BAD,    BAD,    BAD,
//    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,
//    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,
//    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,
//    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,
//    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,
//    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,
//    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,
//    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,
//    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,
//    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,
//    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,
//    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,
//    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,
//    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,
//    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,
//    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,    BAD,
};

static const unsigned char kWebSafe_base64_dec_map[128] = {
// This array was generated by the following code:
// #include <sys/time.h>
// #include <stdlib.h>
// #include <string.h>
// main()
// {
//   static const char Base64[] =
//     "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
//   char *pos;
//   int idx, i, j;
//   printf("    ");
//   for (i = 0; i < 255; i += 8) {
//     for (j = i; j < i + 8; j++) {
//       pos = strchr(Base64, j);
//       if ((pos == NULL) || (j == 0))
//         idx = BAD;
//       else
//         idx = pos - Base64;
//       if (idx == BAD)
//         printf(" %2d,     ", idx);
//       else
//         printf(" %2d/*%c*/,", idx, j);
//     }
//     printf("\n    ");
//   }
// }
	BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,
	BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,
	BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,
	BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,
	BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,
	BAD,      BAD,      BAD,      BAD,      BAD,      62/*-*/,  BAD,      BAD,
	52/*0*/,  53/*1*/,  54/*2*/,  55/*3*/,  56/*4*/,  57/*5*/,  58/*6*/,  59/*7*/,
	60/*8*/,  61/*9*/,  BAD,      BAD,      BAD,      BAD,      BAD,      BAD,
	BAD,      0/*A*/,   1/*B*/,   2/*C*/,   3/*D*/,   4/*E*/,   5/*F*/,   6/*G*/,
	7/*H*/,   8/*I*/,   9/*J*/,   10/*K*/,  11/*L*/,  12/*M*/,  13/*N*/,  14/*O*/,
	15/*P*/,  16/*Q*/,  17/*R*/,  18/*S*/,  19/*T*/,  20/*U*/,  21/*V*/,  22/*W*/,
	23/*X*/,  24/*Y*/,  25/*Z*/,  BAD,      BAD,      BAD,      BAD,      63/*_*/,
	BAD,      26/*a*/,  27/*b*/,  28/*c*/,  29/*d*/,  30/*e*/,  31/*f*/,  32/*g*/,
	33/*h*/,  34/*i*/,  35/*j*/,  36/*k*/,  37/*l*/,  38/*m*/,  39/*n*/,  40/*o*/,
	41/*p*/,  42/*q*/,  43/*r*/,  44/*s*/,  45/*t*/,  46/*u*/,  47/*v*/,  48/*w*/,
	49/*x*/,  50/*y*/,  51/*z*/,  BAD,      BAD,      BAD,      BAD,      BAD,
//	BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,
//	BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,
//	BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,
//	BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,
//	BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,
//	BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,
//	BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,
//	BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,
//	BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,
//	BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,
//	BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,
//	BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,
//	BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,
//	BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,
//	BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,
//	BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD,      BAD
};
/*
 * Encode a buffer into base64 format
 */

int base64_encode_fun(const char *pSrc, int iSrcLen, char *pDst, int *piDstLen, const unsigned char *charSet)
{
	int i, n;
	int c1, c2, c3;
	unsigned char *p;

	if (iSrcLen == 0)
    {
        *pDst = '\0';
        *piDstLen = 0;
        return ERR_OK;
    }
/*
 需要的总输出字节 = (iSrcLen / 3) * 4 + c + 1 c为补齐，1为结束'\0'
 被3整除c＝0，或则c＝4
 每3个字节需要4个字节

*/
//	n = (iSrcLen << 2) / 3;
//
//	switch ((iSrcLen << 2) / 3)
//	{
//        case 1:
//            n += 3;
//            break;
//        case 2:
//            n += 2;
//            break;
//        default:
//            break;
//	}
#ifdef LIBCORE_DEBUG
    n = ((iSrcLen  / 3 ) << 2) + ((iSrcLen % 3) == 0 ? 0 : 4);
	if (*piDstLen < n + 1)
	{
		*piDstLen = n + 1;
		return ERR_BASE64_BUFFER_TOO_SMALL;
	}
#endif
    
	n = (iSrcLen / 3) * 3;
    i = 0, p = (unsigned char *)pDst;
    
	for (; i < n; i += 3)
	{
		c1 = *pSrc++;
		c2 = *pSrc++;
		c3 = *pSrc++;

		*p++ = charSet[(c1 >> 2) & 0x3F];
		*p++ = charSet[(((c1 & 0x03) << 4) + (c2 >> 4)) & 0x3F];
		*p++ = charSet[(((c2 & 0x0F) << 2) + (c3 >> 6)) & 0x3F];
		*p++ = charSet[c3 & 0x3F];
	}
// now deal with the tail (<=2 bytes)
    switch (iSrcLen - i) {
        case 0:
        {
            
        }
            break;
        case 1:
        {
            c1 = *pSrc++;
            c2 = 0;
            *p++ = charSet[(c1 >> 2) & 0x3F];
            *p++ = charSet[(((c1 & 0x03) << 4) + (c2 >> 4)) & 0x3F];
            *p++ = kBase64PaddingChar;
            *p++ = kBase64PaddingChar;
        }
            break;
        case 2:
        {
            c1 = *pSrc++;
            c2 = *pSrc++;
            
            *p++ = charSet[(c1 >> 2) & 0x3F];
            *p++ = charSet[(((c1 & 0x03) << 4) + (c2 >> 4)) & 0x3F];
            *p++ = charSet[((c2 & 0x0F) << 2) & 0x3F];
            *p++ = kBase64PaddingChar;
        }
            break;
            
        default:
            break;
    }
    
	*piDstLen = static_cast<int>((char *)p - pSrc);
	*p = 0;
	return ERR_OK;
}

/*
 * Decode a base64-formatted buffer
 */

int decodeQuantum(unsigned char *pDst, const char *pSrc, const unsigned char *charSet, int/*out*/ *piNeedLeastLength = NULL)
{
    int padding = 0;
    const unsigned char *s;
    unsigned long i, x = 0;
    
    for(i = 0, s = (unsigned char *)pSrc; i < 4; i++, s++) {
        if (*s == kBase64PaddingChar)
        {
            x <<= 6;
            padding++;
        }
        else
        {
            if (*s > kBase64InvalidChar || charSet[*s] == kBase64InvalidChar)
            {
                return ERR_BASE64_INVALID_CHARACTER;
            }
            else
            {
                x <<= 6;
                x += charSet[*s];
            }
        }
    }
    
    if (padding < 1) {
        pDst[2] = x & 0xFF;
    }
    x >>= 8;
    if (padding < 2) {
        pDst[1] = x & 0xFF;
    }
    x >>= 8;
    pDst[0] = x & 0xFF;
    
    if (piNeedLeastLength != NULL) {
        switch (padding) {
            case 0:
            {
                *piNeedLeastLength = 3;
            }
                break;
            case 1:
            {
                *piNeedLeastLength = 2;
            }
                break;
            case 2:
            {
                *piNeedLeastLength = 1;
            }
                break;
                
            default:
                *piNeedLeastLength = 3;
                break;
        }
    }
    
    return ERR_OK;
}

int base64_decode_fun(const char *pSrc, int iSrcLen, char *pDst, int *piDstLen, const unsigned char *charSet)
{
	int i;
	unsigned char *p;
    
    if (iSrcLen % 4 != 0)
    {
        return ERR_BASE64_INVALID_CHARACTER;
    }
    
    if  (iSrcLen == 0)
    {
        *pDst = '\0';
        *piDstLen = 0;
		return ERR_OK;
    }
    
#ifdef LIBCORE_DEBUG
    int padding, n;
    if (iSrcLen > strlen((const char *)pSrc)) {
        return ERR_PARAM_ERR;
    }
    
    if (*piDstLen > sizeof(pDst)) {
        return ERR_OUT_OF_MEMORY;
    }

	for( i = padding = n = 0; i < iSrcLen; i++ )
	{
        /*
		if ((iSrcLen - i ) >= 2 && *(pSrc + i) == '\r' && *(pSrc + i + 1) == '\n')
        {
			continue;
        }

		if (*(pSrc + i) == '\n')
        {
			continue;
        }
         */
		if (*(pSrc + i) == kBase64PaddingChar)
        {
            ++padding;
            if (padding > 2) {
                return ERR_BASE64_INVALID_CHARACTER;
            }
        }

		if (*(pSrc + i) > kBase64InvalidChar || charSet[*(pSrc + i)] == kBase64InvalidChar)
        {
			return ERR_BASE64_INVALID_CHARACTER;
        }

		if (charSet[*(pSrc + i)] < 64 && padding != 0)
        {
			return ERR_BASE64_INVALID_CHARACTER;
        }
		n++;
	}
    /*
    padding = 0;
    if (*(pSrc + iSrcLen - 1) == kBase64PaddingChar) {
        padding++;
    }
    
    if (*(pSrc + iSrcLen - 2) == kBase64PaddingChar) {
        padding++;
    }
    */
    switch (padding) {
        case 0:
        {
            n = iSrcLen / 4 * 3 + 1;
        }
            break;
        case 1:
        {
            n = iSrcLen / 4 * 3;
        }
            break;
        case 2:
        {
            n = iSrcLen / 4 * 3 - 1;
        }
            break;
        default:
            break;
    }
	

	if (*piDstLen < n)
	{
		*piDstLen = n;
		return ERR_BASE64_BUFFER_TOO_SMALL;
	}
#endif
    int numQuantums;
    numQuantums = iSrcLen / 4;
    p = (unsigned char *)pDst;
    for (i = 0; i < numQuantums - 1; i++) {
        CCErrCode err = decodeQuantum(p, pSrc, charSet);
        if (err != ERR_OK) {
            return ERR_BASE64_INVALID_CHARACTER;
        }
        
        p += 3;
        pSrc += 4;
    }
    int iLastQuantumMem = 0;
    
    CCErrCode err = decodeQuantum(p, pSrc, charSet, &iLastQuantumMem);
    if (err != ERR_OK) {
        return ERR_BASE64_INVALID_CHARACTER;
    }
    p += iLastQuantumMem;
    *p = 0;
	*piDstLen = static_cast<int>((char *)p - pDst);

    return ERR_OK;
}

int base64_encode(const char *pSrc, int iSrcLen, char *pDst, int *piDstLen)
{
    return base64_encode_fun(pSrc, iSrcLen, pDst, piDstLen, base64_enc_map);
}

int base64_decode(const char *pSrc, int iSrcLen, char *pDst, int *piDstLen)
{
    return base64_decode_fun(pSrc, iSrcLen, pDst, piDstLen, base64_dec_map);
}

int base64_encode_websafe(const char *pSrc, int iSrcLen, char *pDst, int *piDstLen)
{
    return base64_encode_fun(pSrc, iSrcLen, pDst, piDstLen, kWebSafe_base64_enc_map);
}

int base64_decode_websafe(const char *pSrc, int iSrcLen, char *pDst, int *piDstLen)
{
    return base64_decode_fun(pSrc, iSrcLen, pDst, piDstLen, kWebSafe_base64_dec_map);
}
